PROGRAMA
    VARIABLES
        i,max:NUM;
        s:SEQ(NUM);
    SUBPROGRAMAS
        FUNCION bucle_1_avance(SEQ(NUM) sik, NUM huey) dev (NUM j)
            VARIABLES
            INSTRUCCIONES
                j = 1 + 1;
                dev j;
        FFUNCION

        FUNCION test (NUM ki) dev (NUM ka)
            VARIABLES
                k:NUM;
            INSTRUCCIONES
                k = 111;
                ka = ki*25;
                dev ka;
        FFUNCION


        FUNCION devuelve_1 (NUM i2) dev (NUM res)
            VARIABLES
            INSTRUCCIONES
                dev i2*25;
        FFUNCION

        FUNCION mayor_que_5 () dev (LOG r1, LOG xx2)
            VARIABLES
                k,l:LOG;
            INSTRUCCIONES
                r1=T;
                xx2=F;
                dev r1,xx2;
        FFUNCION

        FUNCION mayor_que_6(NUM x2, LOG x3) dev (LOG r2, LOG r23)
            VARIABLES
                //k:NUM;
                //x,y: NUM;
                a,b,c,d,e:NUM;
                p,k,z,l:LOG;
                cuc:SEQ(LOG);
                hue:SEQ(NUM);
            INSTRUCCIONES
                k = T == T;
                k = T;
                cuc = [k, T, T, T, F];

                hue = [1,1,1,1];
                c = 1 + ultima_posicion(hue);
                l = T == ultima_posicion(cuc);
                //x=15;
                mayor_que_5();
                test(12);
                cuc = [k, T, T, T, F];
                //z = cuc[devuelve_1(x)];
                p,k,z,cuc = mayor_que_5(), vacia([]), [T, ultima_posicion([T,T,F])];
                ////a = test(25);
                ////mostrar([1,2,3]);
                //cuc = [1,1,1];
                //a=[1,3,5,5];
                //a = 1;
                //p = (T==F) == (2<(3<(4<(5<(1)))));
                //k = p;
                //p = (1<1)==(2<12);
                //p = 1<1;
                //p = ((1<1)==(25+1)) == T;
                //b = 5;
                //c, d = a + b, a<1;
                //a,b,c,d,e,p = 1+1,2+2,1+3,4+5,5,5<5;
                //p = mayor_que_6(1,mayor_que_5(1+25));


                dev T, T;
        FFUNCION
    INSTRUCCIONES
        i=0;
        /*

        s = [1,T,3];
        max=s[i];
        mientras (i<=ultima_posicion(s)) hacer {avance: bucle_1_avance(s, i)}
            si (s[i]>max) entonces
                max=s[i];
            fsi
            i=i+1;
        fmientras
        */



 Scope scopeGlobal = new Scope("global");

    //ParseTreeProperty<List<Valor>> valorOperaciones = new ParseTreeProperty<>();
    ParseTreeProperty<Map<String, Valor>> memoria = new ParseTreeProperty<>();
    ParseTreeProperty<Valor> retornosFuncion = new ParseTreeProperty<>();
    ParseTreeProperty<Boolean> rupturaBloque = new ParseTreeProperty<>();

    /*
    private Scope getGlobalScope () {
        return scopeTree.get(raiz).get("global");
    }
    */

    private ParserRuleContext closestInstruccionBlock (ParserRuleContext ctx) {
        if (ctx.getParent().getClass().equals(Anasint.Bloque_instruccionesContext.class))
            return ctx.getParent();
        else
            return closestInstruccionBlock(ctx.getParent());
    }

    private ParserRuleContext closestBreakBlock (ParserRuleContext ctx) {
        if (//ctx.getParent().getClass().equals(Anasint.Bloque_funcionContext.class) ||
                ctx.getParent().getClass().equals(Anasint.Instruccion_controlContext.class) ||
                        ctx.getParent().getClass().equals(Anasint.Instruccion_bucleContext.class) ||
                        ctx.getParent().getClass().equals(Anasint.Bloque_instruccionesContext.class))
            return ctx.getParent();
        else
            return closestBreakBlock(ctx.getParent());
    }

    public Object visitBloque_programa(Anasint.Bloque_programaContext ctx) {
        //List<Variable> variables = visitBloque_variables(ctx.bloque_variables());
        //Scope scopeGlobal = new Scope("global");
        //scopeGlobal.declaraVariables(variables);

        scopeGlobal.declaraSubprogramaNativo("vacia", "Funcion");
        scopeGlobal.declaraSubprogramaNativo("ultima_posicion", "Funcion");
        scopeGlobal.declaraSubprogramaNativo("mostrar", "Procedimieneto");

        //raiz = ctx;
        //Map<String, Scope> scopes = new OrderedHashMap<>();
        //scopes.put(scopeGlobal.getNombre(), scopeGlobal);
        //scopeTree.get("global").put(ctx, scopeGlobal);
        //scopeTree.put(raiz, scopes);
        return super.visitBloque_programa(ctx);
    }

    public Object visitBloque_instrucciones (Anasint.Bloque_instruccionesContext ctx) {
        if (memoria.get(ctx) == null)
            memoria.put(ctx, new HashMap<>());
        for (Anasint.InstruccionContext instruccion: ctx.instruccion()) {
            if (instruccion.instruccion_ruptura() != null)
                break;
            visit(instruccion);
        }
        //return super.visitBloque_instrucciones(ctx);
        return 1;
    }

    public Object visitBloque_funcion (Anasint.Bloque_funcionContext ctx) {
        String nombreFuncion = ctx.IDENT().getText();

        List<Anasint.Lista_variables_tipadasContext> variablesEntradaSalida =  ctx.lista_variables_tipadas();
        List<Variable> entrada = new ArrayList<>();
        List<Variable> salida = new ArrayList<>();

        if (variablesEntradaSalida.size() == 2) {
            entrada.addAll(visitLista_variables_tipadas(variablesEntradaSalida.get(0)));
            salida.addAll(visitLista_variables_tipadas(variablesEntradaSalida.get(1)));
        } else
            salida.addAll(visitLista_variables_tipadas(variablesEntradaSalida.get(0)));

        scopeGlobal.declaraSubprograma(nombreFuncion, "Funcion", entrada, salida);
        scopeGlobal.getSubprograma(nombreFuncion).setPuntero(ctx.bloque_instrucciones());

        return 1;
    }

    public List<Variable> visitBloque_variables(Anasint.Bloque_variablesContext ctx) {
        List<Variable> variables = new ArrayList<>();

        for (Anasint.Declaracion_variableContext variable: ctx.declaracion_variable()) {
            variables.addAll(visitDeclaracion_variable(variable));
        }
        return variables;
        //return super.visitBloque_variables(ctx);
    }

    public List<Variable> visitDeclaracion_variable(Anasint.Declaracion_variableContext ctx) {
        List<Variable> res = new ArrayList<>();
        for (TerminalNode variable: ctx.IDENT())
            res.add(new Variable(variable.getText(), ctx.tipo().getText()));
        return res;
    }

    public List<Variable> visitLista_variables_tipadas (Anasint.Lista_variables_tipadasContext ctx) {
        //System.out.println("first " + ctx.lista_variables_tipadas())
        List<Variable> res = new ArrayList<>();
        for (Anasint.Variable_tipadaContext varTipada: ctx.variable_tipada())
            res.add(new Variable(varTipada.IDENT().getText(), varTipada.tipo().getText()));
        //scope.declaraVariable(varTipada.IDENT().getText(), varTipada.tipo().getText());
        return res;
    }

    public Object visitInstruccion (Anasint.InstruccionContext ctx) {
        //esto hace que ignoremos todas las intrucciones detras de ruptura
        //a nivel de bloque instruccion mas externo
        //if (rupturaBloque.get(ctx.getParent()) != null && rupturaBloque.get(ctx.getParent())) {
        //    System.out.println("[INTERPRETE] visitBloque_instrucciones RUPTURA " + ctx.getText());
            //rupturaBloque.removeFrom(ctx);
        //    return 1;
        //}

        if (retornosFuncion.get(closestInstruccionBlock(ctx)) != null) {
            System.out.println("[INTERPRETE] visitBloque_instrucciones RETORNO memoria de " + ctx.getText() + " " + retornosFuncion.get(closestInstruccionBlock(ctx)).toString());
            System.out.println("[INTERPRETE] visitBloque_instrucciones RETORNO La instruccion no deberia visitarse, un retorno se ha visitado ya " + ctx.getText());
            return 1;
        }

        //if (ctx.instruccion_retorno() != null)
        //    return visitInstruccion_retorno(ctx.instruccion_retorno());
        return super.visitInstruccion(ctx);
    }

    public Object visitInstruccion_ruptura (Anasint.Instruccion_rupturaContext ctx) {
        ParserRuleContext closest = closestBreakBlock(ctx);
        System.out.println("[INTERPRETE] Hemos puesto ruptura en " + closest.getClass());
        //rupturaBloque.put(closestBreakBlock(ctx), true);
        return 1;
    }

    // esto no deberia hacerse aqui, solo funciona para bucles!
    public Object visitInstruccion_bucle (Anasint.Instruccion_bucleContext ctx) {
        //System.out.println("[INTERPRETE] visitInstruccion_bucle " + ctx.predicado().getText());
        boolean ruptura = false;
        while (!ruptura && visitPredicado(ctx.predicado()).getValorBooleano()) {
            System.out.println("[INTERPRETE] visitInstruccion_bucle predicado (" +
                    ctx.predicado().getText() + ") = " +
                    visitPredicado(ctx.predicado()).getValorBooleano());
            for (Anasint.InstruccionContext instruccion: ctx.instruccion())
                if (instruccion.instruccion_retorno() != null)
                    return 1;
                else if (instruccion.instruccion_ruptura() != null) {
                    ruptura = true;
                    break;
                }
                else
                    visitInstruccion(instruccion);
        }
        return 1;
    }

    public Object visitInstruccion_control (Anasint.Instruccion_controlContext ctx) {
        List<Anasint.InstruccionContext> instruccionesSi = new ArrayList<>();
        List<Anasint.InstruccionContext> instruccionesSino = new ArrayList<>();
        boolean encontradoSino = false;

        //dividimos las instrucciones en dos partes, si/sino
        for (ParseTree hijo: ctx.children) {
            if (hijo.equals(ctx.SINO()))
                encontradoSino = true;
            if (hijo.getClass().equals(Anasint.InstruccionContext.class)) {
                if (!encontradoSino)
                    instruccionesSi.add((Anasint.InstruccionContext) hijo);
                else
                    instruccionesSino.add((Anasint.InstruccionContext) hijo);
            }
        }
        //si el predicado es cierto (condicion), entramos a las instrucciones
        boolean valorPredicado = visitPredicado(ctx.predicado()).getValorBooleano();
        System.out.println("[INTERPRETE] visitInstruccion valor predicado " + ctx.predicado().getText() + " = " + valorPredicado);
        if (valorPredicado)
            //se visitan instrucciones si
            for (Anasint.InstruccionContext instruccion: instruccionesSi) {
                if (instruccion.instruccion_ruptura() != null) {
                    System.out.println("[INTERPRETE] visitInstruccion_control NO visitamos la instruccion porque tiene ruptura");
                    break;
                }

                visitInstruccion(instruccion);
                System.out.println("[INTERPRETE] visitInstruccion_control instr si " + instruccion.getText());
            }
        //se visitan las instrucciones sino
        else
            for (Anasint.InstruccionContext instruccion: instruccionesSino) {
                if (instruccion.instruccion_ruptura() != null) {
                    System.out.println("[INTERPRETE] visitInstruccion_control NO visitamos la instruccion porque tiene ruptura");
                    break;
                }
                visitInstruccion(instruccion);
                System.out.println("[INTERPRETE] visitInstruccion_control instr sino " + instruccion.getText());
            }
        return 1;
    }

    public Valor visitInstruccion_retorno (Anasint.Instruccion_retornoContext ctx) {
        Valor res;

        List<Valor> valoresRetorno = new ArrayList<>();

        for (Anasint.Evaluacion_variableContext evalVariable: ctx.evaluaciones_variables().evaluacion_variable()) {
            valoresRetorno.add(visitEvaluacion_variable(evalVariable));
        }

        res = valoresRetorno.get(0);
        res.setValores(valoresRetorno);

        retornosFuncion.put(closestInstruccionBlock(ctx), res);

        System.out.println("[INTERPRETE] visitInstruccion_retorno " + res);
        return res;
    }

    public Object visitInstruccion_asig (Anasint.Instruccion_asigContext ctx) {
        List<Valor> valores = new ArrayList<>();
        //List<Variable> variables = new ArrayList<>();

        //lo enchufamos al bloque padre (instruccion)
        int i = 0;

        for (Anasint.Evaluacion_variableContext evalr: ctx.evaluaciones_variables().evaluacion_variable()) {
            if (evalr.subprograma() != null)
                valores.addAll(visitEvaluacion_variable(evalr).getValores());
            else
                valores.add(visitEvaluacion_variable(evalr));
            //valores.addAll(valorOperaciones.get(evalr));
        }

        //acceder caso especial funcion
        for (Anasint.VariableContext variable: ctx.lista_variables().variable()) {
            String nombreVariable = variable.getText();
            memoria.get(closestInstruccionBlock(variable)).put(nombreVariable, valores.get(i));
            i++;
        }

        System.out.println("[INTERPRETE] Datos de la memoria " + ctx.getParent().getClass() + " , " + memoria.get(closestInstruccionBlock(ctx)));
        return 1;
    }

    public Valor visitSubprograma (Anasint.SubprogramaContext ctx) {

        String nombre = ctx.IDENT().getText();
        Subprograma subprograma = scopeGlobal.getSubprograma(nombre);
        System.out.println("Visitando programa " + ctx.getText() + " tiene memoria? " + memoria.get(subprograma.getPuntero()));

        //Cada vez que entramos en la funcion, limpiamos los datos del nodo
        retornosFuncion.removeFrom(subprograma.getPuntero());
        memoria.removeFrom(subprograma.getPuntero());
        //rupturaBloque.removeFrom
        ////Valor res;
        // hay que hacer una memoria especial con los parametros de entrada
        // cargados con los valores de parametros


        List<Variable> argumentosDeclarados = subprograma.getEntrada();
        Map<String, Valor> memoriaSubprograma = new OrderedHashMap<>();
        List<Valor> valoresInvocacionSubprograma = new ArrayList<>();

        for (Anasint.Evaluacion_variableContext valorArgumento :ctx.evaluacion_variable()) {
            valoresInvocacionSubprograma.add(visitEvaluacion_variable(valorArgumento));
        }

        int i = 0;

        for (Variable argumentoDeclarado: argumentosDeclarados) {
            memoriaSubprograma.put(argumentoDeclarado.getNombre(), valoresInvocacionSubprograma.get(i));
            i++;
        }

        memoria.put(subprograma.getPuntero(), memoriaSubprograma);
        visitBloque_instrucciones((Anasint.Bloque_instruccionesContext) subprograma.getPuntero());

        //visitBloque_instrucciones((Anasint.Bloque_instruccionesContext) scopeTree.get(raiz).get(ctx.IDENT().getText()).getPuntero());
        //List<Valor> valoresRetorno = new ArrayList<Valor>(memoria.get(subprograma.getPuntero()).values());
        //res = valoresRetorno.get(0);
        //res.setValores(valoresRetorno);

        return retornosFuncion.get(subprograma.getPuntero());
    }

    public Valor visitOperando (Anasint.OperandoContext ctx) {
        return (Valor) super.visit(ctx);
    }

    public Valor visitOperando_booleano (Anasint.Operando_booleanoContext ctx) {
        if (ctx.TRUE() != null)
            return new Valor(true);
        else
            return new Valor(false);
    }

    public Valor visitOperando_numerico (Anasint.Operando_numericoContext ctx) {
        return new Valor(Integer.valueOf(ctx.NUMERO().getText()));
    }

    public Valor visitPredicado (Anasint.PredicadoContext ctx) {
        return (Valor) super.visit(ctx);
    }

    public Valor visitPredicado_simple(Anasint.Predicado_simpleContext ctx) {
        return resuelveOperadorCondicion(
                visitOperacion(ctx.operacion(0)),
                visitOperacion(ctx.operacion(1)),
                ctx.operador_condicion_2_ario());
    }

    public Valor visitPredicado_compuesto(Anasint.Predicado_compuestoContext ctx) {
        Valor operadorB = visitPredicado(ctx.predicado());
        if (ctx.NO() != null)
            operadorB.setValorBooleano(!operadorB.getValorBooleano());
        return resuelveOperadorCondicion(
                visitOperacion(ctx.operacion()),
                operadorB,
                ctx.operador_condicion_2_ario());
    }

    public Valor visitPredicado_compuesto_doble(Anasint.Predicado_compuesto_dobleContext ctx) {
        boolean niegaA = false;
        boolean niegaB = false;
        boolean cambio = false;
        Valor operandoA = visitPredicado(ctx.predicado(0));
        Valor operandoB = visitPredicado(ctx.predicado(1));
        if (ctx.NO().size() == 1) {
            for (ParseTree nodo: ctx.children) {
                if (nodo.equals(ctx.operador_condicion_2_ario()))
                    cambio = true;
                if (nodo.equals(ctx.NO(0))) {
                    if (cambio)
                        operandoB.setValorBooleano(operandoB.getValorBooleano());
                    else
                        operandoA.setValorBooleano(operandoA.getValorBooleano());
                }
            }
        }
        return resuelveOperadorCondicion(
                operandoA,
                operandoB,
                ctx.operador_condicion_2_ario());
    }

    public Valor visitVariable (Anasint.VariableContext ctx) {
        return memoria.get(closestInstruccionBlock(ctx)).get(ctx.getText());
    }

    public Valor visitEvaluacion_variable (Anasint.Evaluacion_variableContext ctx) {
        //Valor valor = visit(ctx);
        //valorOperaciones.put(ctx, Arrays.asList(valor));
        return (Valor) super.visitEvaluacion_variable(ctx);
    }

    private Valor resuelveOperadorLogico (Valor a, Valor b, Anasint.Operador_logico_2_arioContext ctx) {
        String operador = ctx.getText();
        boolean res = false;
        //if (a == null || b == null)
        //    return new Valor(new Booleano(true));
        switch (operador) {
            case "==" -> res = a.equals(b);
            case "!=" -> res = !a.equals(b);
            case ">=" -> res = a.getValorNumerico() >= b.getValorNumerico();
            case ">" -> res = a.getValorNumerico() > b.getValorNumerico();
            case "<=" -> res = a.getValorNumerico() <= b.getValorNumerico();
            case "<" -> res = a.getValorNumerico() < b.getValorNumerico();
        }
        return new Valor(res);
    }

    private Valor resuelveOperadorAritmetico (Valor a, Valor b, Anasint.Operador_aritmetico_2_arioContext ctx) {
        String operador = ctx.getText();
        int res = 0;
        //if (a == null || b == null)
        //    return new Valor(new Numero(0));
        switch (operador) {
            case "+" -> res = a.getValorNumerico() + b.getValorNumerico();
            case "-" -> res = a.getValorNumerico() - b.getValorNumerico();
            case "*" -> res = a.getValorNumerico() * b.getValorNumerico();
        }
        return new Valor(res);
    }

    private Valor resuelveOperadorCondicion (Valor a, Valor b, Anasint.Operador_condicion_2_arioContext ctx) {
        String operador = ctx.getText();
        boolean res = false;
        switch (operador) {
            case "&&" -> res = a.getValorBooleano() && b.getValorBooleano();
            case "||" -> res = a.getValorBooleano() || b.getValorBooleano();
            case "==" -> res = a.equals(b);
            case "!=" -> res = !a.equals(b);
            case ">=" -> res = a.getValorNumerico() >= b.getValorNumerico();
            case ">" -> res = a.getValorNumerico() > b.getValorNumerico();
            case "<=" -> res = a.getValorNumerico() <= b.getValorNumerico();
            case "<" -> res = a.getValorNumerico() < b.getValorNumerico();
        }
        return new Valor(res);
    }

    public Valor visitOperacion (Anasint.OperacionContext ctx) {
        return (Valor) super.visit(ctx);
    }
/*
    public Valor visitOperando_secuencia (Anasint.Operando_secuenciaContext ctx) {
        if (ctx.evaluacion_variable() != null)
    }
*/
    public Valor visitOperando_secuencia_vacia (Anasint.Operando_secuencia_vaciaContext ctx) {
        return new Valor(new ArrayList<>());
    }

    public Valor visitOperando_secuencia_logica (Anasint.Operando_secuencia_logicaContext ctx) {
        Valor res;
        List<Object> secuencia = new ArrayList<>();
        for (Anasint.Operando_booleanoContext valorBooleano: ctx.operando_booleano())
            secuencia.add(valorBooleano);
        return new Valor(secuencia);
    }

    public Valor visitOperando_secuencia_numerica (Anasint.Operando_secuencia_numericaContext ctx) {
        Valor res;
        List<Object> secuencia = new ArrayList<>();
        for (TerminalNode numero: ctx.NUMERO())
            secuencia.add(Integer.valueOf(numero.getText()));
        return new Valor(secuencia);
    }
/*
    public Valor visitOp_logica_simple(Anasint.Op_logica_simpleContext ctx) {
        return resuelveOperadorLogico(
                visitOperando(ctx.operando(0)),
                visitOperando(ctx.operando(1)),
                ctx.operador_logico_2_ario());
    }

    public Valor visitOp_logica_compuesta(Anasint.Op_logica_compuestaContext ctx) {
        return resuelveOperadorLogico(
                visitOperando(ctx.operando()),
                visitOperacion(ctx.operacion()),
                ctx.operador_logico_2_ario());
    }

    public Valor visitOp_logica_compuesta_doble(Anasint.Op_logica_compuesta_dobleContext ctx) {
        return resuelveOperadorLogico(
                visitOperacion(ctx.operacion(0)),
                visitOperacion(ctx.operacion(1)),
                ctx.operador_logico_2_ario());
    }
*/
    public Valor visitOp_aritmetica_simple(Anasint.Op_aritmetica_simpleContext ctx) {
        return resuelveOperadorAritmetico(
                visitOperando(ctx.operando(0)),
                visitOperando(ctx.operando(1)),
                ctx.operador_aritmetico_2_ario());
    }

    public Valor visitOp_aritmetica_compuesta(Anasint.Op_aritmetica_compuestaContext ctx) {
        return resuelveOperadorAritmetico(
                visitOperando(ctx.operando()),
                visitOperacion(ctx.operacion()),
                ctx.operador_aritmetico_2_ario());
    }

    public Valor visitOp_aritmetica_compuesta_doble(Anasint.Op_aritmetica_compuesta_dobleContext ctx) {
        return resuelveOperadorAritmetico(
                visitOperacion(ctx.operacion(0)),
                visitOperacion(ctx.operacion(1)),
                ctx.operador_aritmetico_2_ario());
    }
